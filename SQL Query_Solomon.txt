-- CLEANING THE BK_DETAIL TABLE
SELECT * 
FROM FINANCIAL_DATA.PUBLIC.BK_DETAIL BK
LIMIT 100;

-- To check the length of the account numbers for consistency
SELECT LENGTH(ACCOUNT_NUMBER) AS ACC_NUM_LENGTH, COUNT(*) AS LEN_COUNT
FROM FINANCIAL_DATA.PUBLIC.BK_DETAIL
GROUP BY LENGTH(ACCOUNT_NUMBER)
ORDER BY 1;

-- To Delete the wrong column from the Table
DELETE FROM FINANCIAL_DATA.PUBLIC.BK_DETAIL BK
WHERE BK.ACCOUNT_NUMBER NOT LIKE 'DE%' or BK.ACCOUNT_NUMBER IS NULL;

-- To ensure the wrong data has been deleted
SELECT COUNT(DISTINCT ACCOUNT_NUMBER)
FROM FINANCIAL_DATA.PUBLIC.BK_DETAIL BK;

-- To Check for consistency within the Dates Columns
SELECT MIN(MATURITY_DATE) MMD, MIN(ARREARS_SINCE_DATE) MASD, MIN(LOAN_START_DATE) MLSD
FROM FINANCIAL_DATA.PUBLIC.BK_DETAIL BK;


-- CLEANING THE KONTO TABLE
SELECT *
FROM FINANCIAL_DATA.PUBLIC.KONTO KO
LIMIT 100;

-- To check the length of the account numbers for consistency
SELECT LENGTH(ACCOUNT_NUMBER) AS ACC_NUM_LENGTH, COUNT(*) AS LEN_COUNT
FROM FINANCIAL_DATA.PUBLIC.KONTO
GROUP BY LENGTH(ACCOUNT_NUMBER)
ORDER BY 1;


SELECT * 
FROM FINANCIAL_DATA.PUBLIC.KONTO KO
WHERE KO.ACCOUNT_NUMBER NOT LIKE 'DE%' or KO.ACCOUNT_NUMBER IS NULL;

SELECT * 
FROM FINANCIAL_DATA.PUBLIC.KONTO KO
WHERE KO.CUSTOMER_NUMBER NOT LIKE 'C%' or KO.CUSTOMER_NUMBER IS NULL;

-- To delete the wrong entry in the Konto Table
DELETE FROM FINANCIAL_DATA.PUBLIC.KONTO KO
WHERE KO.ACCOUNT_NUMBER NOT LIKE 'DE%' or KO.ACCOUNT_NUMBER IS NULL;

-- To ensure the wrong data has been deleted
SELECT COUNT(DISTINCT ACCOUNT_NUMBER)
FROM FINANCIAL_DATA.PUBLIC.KONTO KO;


-- CLEANING THE KUNDE TABLE
SELECT *
FROM FINANCIAL_DATA.PUBLIC.KUNDE KU
LIMIT 100;

-- To check the length of the account numbers for consistency
SELECT LENGTH(ACCOUNT_NUMBER) AS ACC_NUM_LENGTH, COUNT(*) AS LEN_COUNT
FROM FINANCIAL_DATA.PUBLIC.KUNDE
GROUP BY LENGTH(ACCOUNT_NUMBER)
ORDER BY 1;

SELECT * 
FROM FINANCIAL_DATA.PUBLIC.KUNDE KU
WHERE KU.ACCOUNT_NUMBER NOT LIKE 'DE%' or KU.ACCOUNT_NUMBER IS NULL;

SELECT * 
FROM FINANCIAL_DATA.PUBLIC.KUNDE KU
WHERE KU.CUSTOMER_NUMBER NOT LIKE 'C%' or KU.CUSTOMER_NUMBER IS NULL;

-- To delete the wrong entry in the Kunde Table
DELETE FROM FINANCIAL_DATA.PUBLIC.KUNDE KU
WHERE KU.CUSTOMER_NUMBER NOT LIKE 'C%' or KU.CUSTOMER_NUMBER IS NULL;

-- To find the non-numeric data in Postal_Code Column
SELECT *, TRY_CAST(POSTAL_CODE AS INT) AS POST_CODE_INT
FROM FINANCIAL_DATA.PUBLIC.KUNDE KU
WHERE POST_CODE_INT IS NULL;

ALTER TABLE FINANCIAL_DATA.PUBLIC.KUNDE
ADD COLUMN TOWN VARCHAR(255);

UPDATE FINANCIAL_DATA.PUBLIC.KUNDE
SET TOWN = POSTAL_CODE
WHERE TRY_CAST(POSTAL_CODE AS INT) IS NULL;

-- To update special characters
UPDATE FINANCIAL_DATA.PUBLIC.KUNDE
SET TOWN = REPLACE(TOWN,'�','ss')
WHERE CUSTOMER_NUMBER = 'C000649747';

UPDATE FINANCIAL_DATA.PUBLIC.KUNDE
SET TOWN = REPLACE(TOWN,'�','u')
WHERE CUSTOMER_NUMBER = 'C001050909';


UPDATE FINANCIAL_DATA.PUBLIC.KUNDE
SET POSTAL_CODE = CASE
    WHEN TOWN = 'Halle' THEN '06108'
    WHEN TOWN = 'Gross-Umstadt' THEN '64823'
    WHEN TOWN = 'Lippstadt' THEN '59555'
    WHEN TOWN = 'Wildpoldsried' THEN '87499'
    WHEN TOWN = 'Ingolstadt' THEN '85049'
    WHEN TOWN = 'Altenstadt' THEN '63674'
    WHEN TOWN = 'Lubeck' THEN '23552'
    WHEN TOWN = 'Ostfriesland' THEN '26721' -- assuming Emden
    WHEN TOWN = 'Ostseebad' THEN '18609' -- assuming Ostseebad Binz
    WHEN TOWN = 'Goethestadt' THEN '99423' -- assuming Weimar
    ELSE Postal_Code
END
WHERE TOWN IN ('Halle', 'Gross-Umstadt', 'Lippstadt', 'Wildpoldsried', 'Ingolstadt', 'Altenstadt', 'Lubeck', 'Ostfriesland', 'Ostseebad', 'Goethestadt');

-- To Trim the POSTAL CODE and Update
UPDATE FINANCIAL_DATA.PUBLIC.KUNDE
SET POSTAL_CODE = TRIM(POSTAL_CODE)

-- To fill null values in the Country column with DE
SELECT *
FROM FINANCIAL_DATA.PUBLIC.KUNDE
WHERE COUNTRY IS NULL;

UPDATE FINANCIAL_DATA.PUBLIC.KUNDE
SET COUNTRY = 'DE'
WHERE COUNTRY IS NULL;

ALTER TABLE FINANCIAL_DATA.PUBLIC.KUNDE
DROP COLUMN TOWN;

-- To ensure the wrong data has been deleted
SELECT COUNT(DISTINCT ACCOUNT_NUMBER)
FROM FINANCIAL_DATA.PUBLIC.KUNDE KU;


-- CLEANING THE BUCHUNG TABLE

SELECT *
FROM FINANCIAL_DATA.PUBLIC.BUCHUNG;

SELECT *
FROM FINANCIAL_DATA.PUBLIC.BUCHUNG
WHERE ACCOUNT_NUMBER_ADDITION IS NULL;

-- To check the length of the account numbers for consistency
SELECT LENGTH(ACCOUNT_NUMBER) AS ACC_NUM_LENGTH, COUNT(*) AS LEN_COUNT
FROM FINANCIAL_DATA.PUBLIC.BUCHUNG
GROUP BY LENGTH(ACCOUNT_NUMBER)
ORDER BY 1;

SELECT LENGTH(ACCOUNT_NUMBER_ADDITION) AS ACC_NUM_ADD_LENGTH, COUNT(*) AS LEN_COUNT
FROM FINANCIAL_DATA.PUBLIC.BUCHUNG
GROUP BY LENGTH(ACCOUNT_NUMBER_ADDITION)
ORDER BY 1;

-- To delete the erroneous data in the accounts data
DELETE FROM FINANCIAL_DATA.PUBLIC.BUCHUNG
WHERE LENGTH(ACCOUNT_NUMBER_ADDITION) = 3;

-- To merge the account info to form the account_number column
ALTER TABLE FINANCIAL_DATA.PUBLIC.BUCHUNG
RENAME COLUMN ACCOUNT_NUMBER to ACCOUNT_NUMBER_PART;

ALTER TABLE FINANCIAL_DATA.PUBLIC.BUCHUNG
ADD COLUMN ACCOUNT_NUMBER VARCHAR(255);

UPDATE FINANCIAL_DATA.PUBLIC.BUCHUNG
SET ACCOUNT_NUMBER = CONCAT(ACCOUNT_NUMBER_ADDITION, ACCOUNT_NUMBER_PART);

-- To trim the information on the booking_type column
UPDATE FINANCIAL_DATA.PUBLIC.BUCHUNG
SET BOOKING_TYPE = TRIM(BOOKING_TYPE);

UPDATE FINANCIAL_DATA.PUBLIC.BUCHUNG
SET BOOKING_TYPE = REPLACE(BOOKING_TYPE,'�','u');

-- To replace the values for the encoding

UPDATE FINANCIAL_DATA.PUBLIC.BUCHUNG
SET booking_status = 
    CASE 
        WHEN booking_status = 1 THEN 'Deferred'
        WHEN booking_status = 2 THEN 'Processed'
        WHEN booking_status = 3 THEN 'Free for processing'
        WHEN booking_status = 4 THEN 'Reversed'
        WHEN booking_status = 5 THEN 'Misposted'
        WHEN booking_status = 6 THEN 'Deleted'
        WHEN booking_status = 7 THEN 'Reversal Disbursement'
        WHEN booking_status = 8 THEN 'Internal tax posting for payment distribution (delete after export)'
        WHEN booking_status = 9 THEN 'Unresolved taxed out revenue'
        WHEN booking_status = 10 THEN 'Clarified distributed revenue'
        WHEN booking_status = 11 THEN 'Split revenue'
        WHEN booking_status = 12 THEN 'Unresolved to FiBu'
        WHEN booking_status = 13 THEN 'Suspended'
        WHEN booking_status = 14 THEN 'Free for release'
        WHEN booking_status = 15 THEN 'Release rejected'
        WHEN booking_status = 16 THEN 'Free for cancellation release'
        WHEN booking_status = 17 THEN 'Cancelled'
        WHEN booking_status = 18 THEN 'Cancelled unprocessed'
        ELSE booking_status
    END;


ALTER TABLE FINANCIAL_DATA.PUBLIC.KONTO
ADD COLUMN SPV_TAG_DEF VARCHAR(255);

-- Reseting the SPV_TAG
UPDATE FINANCIAL_DATA.PUBLIC.KONTO
SET SPV_TAG_DEF = CASE 
        WHEN SPV_TAG = 10 THEN 'En_bv'
        WHEN SPV_TAG = 20 THEN 'GF_Alpha'
        ELSE NULL
    END;


SELECT COUNT(*)
FROM (
    SELECT DISTINCT *
    FROM FINANCIAL_DATA.PUBLIC.BUCHUNG
) AS distinct_rows;

SELECT COUNT (*) AS Total_rows
FROM FINANCIAL_DATA.PUBLIC.BUCHUNG;

-- Suspected duplicate rows present

WITH DuplicateCounts AS (
    SELECT *,
           COUNT(*) OVER (PARTITION BY AMOUNT, BOOKING_TYPE, BOOKING_DATE, BOOKING_KEY, BOOKING_STATUS, CREDIT_DEBIT, VALUTA_DATE, PROCESSING_KEY, ACCOUNT_NUMBER) as cnt
    FROM FINANCIAL_DATA.PUBLIC.BUCHUNG
)
SELECT AMOUNT, BOOKING_TYPE, BOOKING_DATE, BOOKING_KEY, BOOKING_STATUS, CREDIT_DEBIT, VALUTA_DATE, PROCESSING_KEY, ACCOUNT_NUMBER, cnt
FROM DuplicateCounts
WHERE cnt > 1
ORDER BY AMOUNT, BOOKING_TYPE, BOOKING_DATE, BOOKING_KEY, BOOKING_STATUS, CREDIT_DEBIT, VALUTA_DATE, PROCESSING_KEY, ACCOUNT_NUMBER, cnt;


-- Handling Duplicates


USE DATABASE FINANCIAL_DATA;

CREATE TABLE TEMP_UNIQUE AS
SELECT DISTINCT AMOUNT, BOOKING_TYPE, BOOKING_DATE, BOOKING_KEY, BOOKING_STATUS, CREDIT_DEBIT, VALUTA_DATE, PROCESSING_KEY, ACCOUNT_NUMBER
FROM FINANCIAL_DATA.PUBLIC.BUCHUNG;

SELECT * FROM TEMP_UNIQUE

-- Archiving the old data and changing the name of the new distinct table
ALTER TABLE TEMP_UNIQUE RENAME TO FINANCIAL_DATA.PUBLIC.BUCHUNG_NEW


--To Count the distinct Booking Types in the Buchung Table
SELECT DISTINCT BOOKING_TYPE AS Booking_Type, COUNT(*) AS Type_Count
FROM FINANCIAL_DATA.PUBLIC.BUCHUNG_NEW
GROUP BY Booking_Type

SELECT *
FROM FINANCIAL_DATA.PUBLIC.BUCHUNG_NEW
WHERE BOOKING_TYPE LIKE '%Sondertilgung%'

---------------------------- END OF CLEANING


-- General Customer Base Demographics Data from Kunde Table

-- Based on Gender
SELECT COUNT(DISTINCT ACCOUNT_NUMBER) AS ACC_COUNT, SALUTATION
FROM FINANCIAL_DATA.PUBLIC.KUNDE
GROUP BY SALUTATION

--Based on Location in Germany
SELECT
    CASE
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '01' AND '04' THEN 'Saxony'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '06' AND '09' THEN 'Saxony-Anhalt'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '07' AND '08' THEN 'Thuringia'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '10' AND '14' THEN 'Berlin'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '15' AND '16' THEN 'Brandenburg'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '17' AND '19' THEN 'Mecklenburg-Vorpommern'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '20' AND '22' THEN 'Hamburg'
        WHEN LEFT(POSTAL_CODE, 2) = '28' THEN 'Bremen'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '23' AND '29' THEN 'Lower Saxony'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '30' AND '39' THEN 'Lower Saxony'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '40' AND '53' THEN 'North Rhine-Westphalia'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '54' AND '56' THEN 'Rhineland-Palatinate'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '57' AND '59' THEN 'Saarland'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '60' AND '65' THEN 'Hesse'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '66' AND '69' THEN 'Rhineland-Palatinate'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '70' AND '79' THEN 'Baden-Württemberg'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '80' AND '89' THEN 'Bavaria'
        WHEN LEFT(POSTAL_CODE, 2) BETWEEN '90' AND '99' THEN 'Bavaria'
        ELSE 'Other'
    END AS State,
    COUNT(*) AS No_of_Postal_Codes
FROM FINANCIAL_DATA.PUBLIC.KUNDE
GROUP BY State
ORDER BY No_of_Postal_Codes DESC;

--Number of Accounts
SELECT COUNT (DISTINCT CUSTOMER_NUMBER)AS No_of_Customers
FROM FINANCIAL_DATA.PUBLIC.KUNDE


-- Joining the Data
SELECT 
    ROW_NUMBER() OVER (ORDER BY KU.ACCOUNT_NUMBER) AS ID,
    KU.SALUTATION,
    KU.POSTAL_CODE,
    KO.CUSTOMER_NUMBER,
    KO.SPV_TAG_DEF,
    KO.ACCOUNT_BALANCE,
    BKD.CURRENT_PRINCIPAL_BALANCE, 
    BKD.LOAN_START_DATE, 
    BKD.ORIGINAL_BALANCE,
    BKD.ANNUITY,
    BKD.CREDIT_SCORE,
    LEFT(KU.POSTAL_CODE, 2) AS REG_POSTALCODE,
    BU.BOOKING_TYPE,
    BU.BOOKING_STATUS,
    BU.ACCOUNT_NUMBER,
    SUM(BU.AMOUNT) AS TOTAL_AMOUNT
FROM FINANCIAL_DATA.PUBLIC.KUNDE AS KU
JOIN FINANCIAL_DATA.PUBLIC.KONTO AS KO ON KU.ACCOUNT_NUMBER = KO.ACCOUNT_NUMBER
JOIN FINANCIAL_DATA.PUBLIC.BK_DETAIL AS BKD ON KU.ACCOUNT_NUMBER = BKD.ACCOUNT_NUMBER
JOIN FINANCIAL_DATA.PUBLIC.BUCHUNG_NEW AS BU ON KU.ACCOUNT_NUMBER = BU.ACCOUNT_NUMBER
GROUP BY 
    KU.POSTAL_CODE,
    KU.SALUTATION, 
    KO.CUSTOMER_NUMBER, 
    KO.SPV_TAG_DEF,
    KO.ACCOUNT_BALANCE,
    BKD.CURRENT_PRINCIPAL_BALANCE, 
    BKD.LOAN_START_DATE, 
    BKD.ORIGINAL_BALANCE,
    BKD.ANNUITY,
    BKD.CREDIT_SCORE,
    BU.BOOKING_TYPE,
    BU.BOOKING_STATUS,
    BU.ACCOUNT_NUMBER,
    KU.ACCOUNT_NUMBER
ORDER BY TOTAL_AMOUNT DESC;



WITH T1 AS (SELECT 
    ROW_NUMBER() OVER (ORDER BY KU.ACCOUNT_NUMBER) AS ID,
    KU.SALUTATION,
    KU.POSTAL_CODE,
    KO.CUSTOMER_NUMBER,
    KO.SPV_TAG_DEF,
    KO.ACCOUNT_BALANCE,
    BKD.CURRENT_PRINCIPAL_BALANCE, 
    BKD.LOAN_START_DATE, 
    BKD.ORIGINAL_BALANCE,
    BKD.ANNUITY,
    BKD.CREDIT_SCORE,
    LEFT(KU.POSTAL_CODE, 2) AS REG_POSTALCODE,
    BU.BOOKING_TYPE,
    BU.BOOKING_STATUS,
    BU.ACCOUNT_NUMBER,
    SUM(BU.AMOUNT) AS TOTAL_PREPAYMENT
FROM FINANCIAL_DATA.PUBLIC.KUNDE AS KU
JOIN FINANCIAL_DATA.PUBLIC.KONTO AS KO ON KU.ACCOUNT_NUMBER = KO.ACCOUNT_NUMBER
JOIN FINANCIAL_DATA.PUBLIC.BK_DETAIL AS BKD ON KU.ACCOUNT_NUMBER = BKD.ACCOUNT_NUMBER
JOIN FINANCIAL_DATA.PUBLIC.BUCHUNG_NEW AS BU ON KU.ACCOUNT_NUMBER = BU.ACCOUNT_NUMBER
WHERE BU.BOOKING_TYPE LIKE '%Gezahlte Sondertilgung auf Kapital%' AND BU.BOOKING_STATUS = 'Processed' 
GROUP BY 
    KU.POSTAL_CODE,
    KU.SALUTATION, 
    KO.CUSTOMER_NUMBER, 
    KO.SPV_TAG_DEF,
    KO.ACCOUNT_BALANCE,
    BKD.CURRENT_PRINCIPAL_BALANCE, 
    BKD.LOAN_START_DATE, 
    BKD.ORIGINAL_BALANCE,
    BKD.ANNUITY,
    BKD.CREDIT_SCORE,
    BU.BOOKING_TYPE,
    BU.BOOKING_STATUS,
    BU.ACCOUNT_NUMBER,
    KU.ACCOUNT_NUMBER
ORDER BY TOTAL_PREPAYMENT DESC)

SELECT BOOKING_STATUS,
    CASE
        WHEN TOTAL_PREPAYMENT < 5000 THEN 'Under 5K'
        WHEN TOTAL_PREPAYMENT >= 5000 AND TOTAL_PREPAYMENT < 10000 THEN '5K - 10K'
        WHEN TOTAL_PREPAYMENT >= 10000 AND TOTAL_PREPAYMENT < 20000 THEN '10K - 20K'
        WHEN TOTAL_PREPAYMENT >= 20000 AND TOTAL_PREPAYMENT < 30000 THEN '20K - 30K'
        WHEN TOTAL_PREPAYMENT >= 30000 AND TOTAL_PREPAYMENT < 40000 THEN '30K - 40K'
        WHEN TOTAL_PREPAYMENT >= 40000 THEN 'Over 40K'
        ELSE 'No Class'
    END AS Transaction_Class,
    COUNT(Transaction_Class) AS Class_Count
FROM T1
GROUP BY BOOKING_STATUS, Transaction_Class;

SELECT 
    ROW_NUMBER() OVER (ORDER BY KU.ACCOUNT_NUMBER) AS ID,
    KU.SALUTATION,
    KU.POSTAL_CODE,
    KO.CUSTOMER_NUMBER,
    KO.SPV_TAG_DEF,
    KO.ACCOUNT_BALANCE,
    BKD.CURRENT_PRINCIPAL_BALANCE, 
    BKD.LOAN_START_DATE, 
    BKD.ORIGINAL_BALANCE,
    BKD.ANNUITY,
    BKD.CREDIT_SCORE,
    LEFT(KU.POSTAL_CODE, 2) AS REG_POSTALCODE,
    BU.BOOKING_TYPE,
    BU.BOOKING_STATUS,
    BU.ACCOUNT_NUMBER,
    SUM(BU.AMOUNT) AS TOTAL_PREPAYMENT
FROM FINANCIAL_DATA.PUBLIC.KUNDE AS KU
JOIN FINANCIAL_DATA.PUBLIC.KONTO AS KO ON KU.ACCOUNT_NUMBER = KO.ACCOUNT_NUMBER
JOIN FINANCIAL_DATA.PUBLIC.BK_DETAIL AS BKD ON KU.ACCOUNT_NUMBER = BKD.ACCOUNT_NUMBER
JOIN FINANCIAL_DATA.PUBLIC.BUCHUNG_NEW AS BU ON KU.ACCOUNT_NUMBER = BU.ACCOUNT_NUMBER
WHERE BU.BOOKING_TYPE LIKE 'Storno Sondertilgung'
GROUP BY 
    KU.POSTAL_CODE,
    KU.SALUTATION, 
    KO.CUSTOMER_NUMBER, 
    KO.SPV_TAG_DEF,
    KO.ACCOUNT_BALANCE,
    BKD.CURRENT_PRINCIPAL_BALANCE, 
    BKD.LOAN_START_DATE, 
    BKD.ORIGINAL_BALANCE,
    BKD.ANNUITY,
    BKD.CREDIT_SCORE,
    BU.BOOKING_TYPE,
    BU.BOOKING_STATUS,
    BU.ACCOUNT_NUMBER,
    KU.ACCOUNT_NUMBER
ORDER BY TOTAL_PREPAYMENT DESC;


SELECT 
    ROW_NUMBER() OVER (ORDER BY KU.ACCOUNT_NUMBER) AS ID,
    KU.SALUTATION,
    KU.POSTAL_CODE,
    KO.CUSTOMER_NUMBER,
    KO.SPV_TAG_DEF,
    KO.ACCOUNT_BALANCE,
    BKD.CURRENT_PRINCIPAL_BALANCE, 
    BKD.LOAN_START_DATE, 
    BKD.ORIGINAL_BALANCE,
    BKD.ANNUITY,
    BKD.CREDIT_SCORE,
    LEFT(KU.POSTAL_CODE, 2) AS REG_POSTALCODE,
    BU.BOOKING_TYPE,
    BU.BOOKING_STATUS,
    BU.ACCOUNT_NUMBER,
    SUM(BU.AMOUNT) AS TOTAL_PREPAYMENT
FROM FINANCIAL_DATA.PUBLIC.KUNDE AS KU
JOIN FINANCIAL_DATA.PUBLIC.KONTO AS KO ON KU.ACCOUNT_NUMBER = KO.ACCOUNT_NUMBER
JOIN FINANCIAL_DATA.PUBLIC.BK_DETAIL AS BKD ON KU.ACCOUNT_NUMBER = BKD.ACCOUNT_NUMBER
JOIN FINANCIAL_DATA.PUBLIC.BUCHUNG_NEW AS BU ON KU.ACCOUNT_NUMBER = BU.ACCOUNT_NUMBER
WHERE BU.BOOKING_TYPE LIKE 'Storno Sondertilgung (ohne Ruckstand)'
GROUP BY 
    KU.POSTAL_CODE,
    KU.SALUTATION, 
    KO.CUSTOMER_NUMBER, 
    KO.SPV_TAG_DEF,
    KO.ACCOUNT_BALANCE,
    BKD.CURRENT_PRINCIPAL_BALANCE, 
    BKD.LOAN_START_DATE, 
    BKD.ORIGINAL_BALANCE,
    BKD.ANNUITY,
    BKD.CREDIT_SCORE,
    BU.BOOKING_TYPE,
    BU.BOOKING_STATUS,
    BU.ACCOUNT_NUMBER,
    KU.ACCOUNT_NUMBER
ORDER BY TOTAL_PREPAYMENT DESC;

----For Manipulation
SELECT BKD.CREDIT_SCORE, COUNT(BKD.CREDIT_SCORE) AS TOTAL_PER_SCORE
FROM FINANCIAL_DATA.PUBLIC.KUNDE AS KU
JOIN FINANCIAL_DATA.PUBLIC.KONTO AS KO ON KU.ACCOUNT_NUMBER = KO.ACCOUNT_NUMBER
JOIN FINANCIAL_DATA.PUBLIC.BK_DETAIL AS BKD ON KU.ACCOUNT_NUMBER = BKD.ACCOUNT_NUMBER
GROUP BY 
    BKD.CREDIT_SCORE
ORDER BY TOTAL_PER_SCORE DESC;
